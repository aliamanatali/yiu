import { Conversation, Message, UsageTracking, UserSubscription } from "./types";

const STORAGE_KEYS = {
  CONVERSATIONS: "ai-chat-conversations",
  MESSAGES: "ai-chat-messages",
  USAGE: "ai-chat-usage",
  SUBSCRIPTION: "ai-chat-subscription",
};

// Conversation Management
export function getConversations(): Conversation[] {
  if (typeof window === "undefined") return [];
  const data = localStorage.getItem(STORAGE_KEYS.CONVERSATIONS);
  if (!data) return [];
  const conversations = JSON.parse(data) as Conversation[];
  // Convert date strings back to Date objects
  return conversations.map((conv) => ({
    ...conv,
    createdAt: new Date(conv.createdAt),
    updatedAt: new Date(conv.updatedAt),
    lastMessageAt: new Date(conv.lastMessageAt),
  }));
}

export function getConversation(id: string): Conversation | null {
  const conversations = getConversations();
  return conversations.find((conv) => conv.id === id) || null;
}

export function createConversation(title?: string): Conversation {
  const now = new Date();
  const conversation: Conversation = {
    id: crypto.randomUUID(),
    title: title || "New Conversation",
    autoGeneratedTitle: !title,
    createdAt: now,
    updatedAt: now,
    lastMessageAt: now,
    messageCount: 0,
    status: "active",
    tags: [],
    isPinned: false,
  };

  const conversations = getConversations();
  conversations.unshift(conversation);
  localStorage.setItem(STORAGE_KEYS.CONVERSATIONS, JSON.stringify(conversations));
  return conversation;
}

export function updateConversation(id: string, updates: Partial<Conversation>): void {
  const conversations = getConversations();
  const index = conversations.findIndex((conv) => conv.id === id);
  if (index !== -1) {
    conversations[index] = {
      ...conversations[index],
      ...updates,
      updatedAt: new Date(),
    };
    localStorage.setItem(STORAGE_KEYS.CONVERSATIONS, JSON.stringify(conversations));
  }
}

export function deleteConversation(id: string): void {
  const conversations = getConversations();
  const filtered = conversations.filter((conv) => conv.id !== id);
  localStorage.setItem(STORAGE_KEYS.CONVERSATIONS, JSON.stringify(filtered));
  
  // Also delete all messages in this conversation
  const allMessages = getAllMessages();
  const remainingMessages = allMessages.filter(
    (msg) => msg.conversationId !== id
  );
  localStorage.setItem(STORAGE_KEYS.MESSAGES, JSON.stringify(remainingMessages));
}

export function archiveConversation(id: string): void {
  updateConversation(id, { status: "archived" });
}

export function pinConversation(id: string, isPinned: boolean): void {
  updateConversation(id, { isPinned });
}

// Message Management
function getAllMessages(): Message[] {
  if (typeof window === "undefined") return [];
  const data = localStorage.getItem(STORAGE_KEYS.MESSAGES);
  if (!data) return [];
  const messages = JSON.parse(data) as Message[];
  return messages.map((msg) => ({
    ...msg,
    timestamp: new Date(msg.timestamp),
  }));
}

export function getMessages(conversationId: string): Message[] {
  const allMessages = getAllMessages();
  return allMessages.filter((msg) => msg.conversationId === conversationId);
}

export function createMessage(
  conversationId: string,
  sender: "user" | "ai",
  content: string
): Message {
  const message: Message = {
    id: crypto.randomUUID(),
    conversationId,
    sender,
    content,
    timestamp: new Date(),
    isEdited: false,
    rating: null,
  };

  const allMessages = getAllMessages();
  allMessages.push(message);
  localStorage.setItem(STORAGE_KEYS.MESSAGES, JSON.stringify(allMessages));

  // Update conversation metadata
  const conversation = getConversation(conversationId);
  if (conversation) {
    updateConversation(conversationId, {
      messageCount: conversation.messageCount + 1,
      lastMessageAt: new Date(),
    });

    // Auto-generate title from first user message if needed
    if (conversation.autoGeneratedTitle && sender === "user" && conversation.messageCount === 0) {
      const title = content.slice(0, 50) + (content.length > 50 ? "..." : "");
      updateConversation(conversationId, { title, autoGeneratedTitle: true });
    }
  }

  return message;
}

export function updateMessage(
  id: string,
  updates: Partial<Message>
): void {
  const allMessages = getAllMessages();
  const index = allMessages.findIndex((msg) => msg.id === id);
  if (index !== -1) {
    allMessages[index] = {
      ...allMessages[index],
      ...updates,
      isEdited: true,
    };
    localStorage.setItem(STORAGE_KEYS.MESSAGES, JSON.stringify(allMessages));
  }
}

export function deleteMessage(id: string): void {
  const allMessages = getAllMessages();
  const message = allMessages.find((msg) => msg.id === id);
  
  if (message) {
    // Remove the message and any AI response that followed
    const filtered = allMessages.filter((msg) => {
      if (msg.id === id) return false;
      // If this is a user message, also remove the next AI message
      if (message.sender === "user") {
        const messageIndex = allMessages.findIndex((m) => m.id === id);
        const nextMessage = allMessages[messageIndex + 1];
        if (nextMessage && nextMessage.sender === "ai" && msg.id === nextMessage.id) {
          return false;
        }
      }
      return true;
    });
    
    localStorage.setItem(STORAGE_KEYS.MESSAGES, JSON.stringify(filtered));

    // Update conversation message count
    const conversation = getConversation(message.conversationId);
    if (conversation) {
      const newCount = Math.max(0, conversation.messageCount - 1);
      updateConversation(message.conversationId, { messageCount: newCount });
    }
  }
}

export function rateMessage(id: string, rating: "up" | "down" | null): void {
  updateMessage(id, { rating });
}

// Usage Tracking
export function getUsageToday(): UsageTracking {
  if (typeof window === "undefined") {
    return { date: new Date().toDateString(), messageCount: 0, resetAt: new Date() };
  }
  
  const today = new Date().toDateString();
  const data = localStorage.getItem(STORAGE_KEYS.USAGE);
  
  if (!data) {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);
    
    const usage: UsageTracking = {
      date: today,
      messageCount: 0,
      resetAt: tomorrow,
    };
    localStorage.setItem(STORAGE_KEYS.USAGE, JSON.stringify(usage));
    return usage;
  }

  const usage = JSON.parse(data);
  usage.resetAt = new Date(usage.resetAt);

  // Reset if it's a new day
  if (usage.date !== today) {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);
    
    const newUsage: UsageTracking = {
      date: today,
      messageCount: 0,
      resetAt: tomorrow,
    };
    localStorage.setItem(STORAGE_KEYS.USAGE, JSON.stringify(newUsage));
    return newUsage;
  }

  return usage;
}

export function incrementUsage(): void {
  const usage = getUsageToday();
  usage.messageCount += 1;
  localStorage.setItem(STORAGE_KEYS.USAGE, JSON.stringify(usage));
}

export function canSendMessage(): boolean {
  const subscription = getSubscription();
  const usage = getUsageToday();

  const limits = {
    free: 20,
    pro: 500,
    plus: Infinity,
  };

  return usage.messageCount < limits[subscription.planType];
}

export function getMessageLimit(): number {
  const subscription = getSubscription();
  const limits = {
    free: 20,
    pro: 500,
    plus: Infinity,
  };
  return limits[subscription.planType];
}

// Subscription Management
export function getSubscription(): UserSubscription {
  if (typeof window === "undefined") {
    return { planType: "free", status: "active" };
  }
  
  const data = localStorage.getItem(STORAGE_KEYS.SUBSCRIPTION);
  if (!data) {
    const subscription: UserSubscription = {
      planType: "free",
      status: "active",
    };
    localStorage.setItem(STORAGE_KEYS.SUBSCRIPTION, JSON.stringify(subscription));
    return subscription;
  }

  const subscription = JSON.parse(data);
  if (subscription.currentPeriodEnd) {
    subscription.currentPeriodEnd = new Date(subscription.currentPeriodEnd);
  }
  return subscription;
}

export function updateSubscription(subscription: UserSubscription): void {
  localStorage.setItem(STORAGE_KEYS.SUBSCRIPTION, JSON.stringify(subscription));
}

// Search and Filter
export function searchConversations(query: string): Conversation[] {
  const conversations = getConversations();
  const lowerQuery = query.toLowerCase();

  return conversations.filter((conv) => {
    // Search in title
    if (conv.title.toLowerCase().includes(lowerQuery)) return true;

    // Search in message content
    const messages = getMessages(conv.id);
    return messages.some((msg) =>
      msg.content.toLowerCase().includes(lowerQuery)
    );
  });
}

export function getConversationsByStatus(
  status: "active" | "archived"
): Conversation[] {
  const conversations = getConversations();
  return conversations.filter((conv) => conv.status === status);
}

export function getPinnedConversations(): Conversation[] {
  const conversations = getConversations();
  return conversations.filter((conv) => conv.isPinned);
}

// Initialize with demo data if empty
export function initializeDemoData(): void {
  const conversations = getConversations();
  if (conversations.length === 0) {
    const conv = createConversation("Writing a Blog Post");
    
    createMessage(conv.id, "user", "Can you help me write a blog post about productivity?");
    createMessage(
      conv.id,
      "ai",
      "I'd be happy to help you write a blog post about productivity! To make it perfect for your audience, could you tell me:\n\n1. Who is your target audience? (e.g., entrepreneurs, students, remote workers)\n2. What aspect of productivity do you want to focus on? (e.g., time management, tools, habits)\n3. What length are you aiming for? (e.g., 500 words, 1000 words)\n\nThis will help me create a blog post that resonates with your readers!"
    );
    
    createMessage(conv.id, "user", "I want to write for remote workers, focusing on time management techniques. Around 800 words would be good.");
    createMessage(
      conv.id,
      "ai",
      "Perfect! Here's a draft blog post for remote workers about time management:\n\n**Mastering Time Management: A Remote Worker's Guide to Peak Productivity**\n\nWorking remotely offers incredible freedom, but it also comes with unique challenges. Without the structure of an office environment, managing your time effectively becomes crucial. Here are proven strategies to help you maximize productivity while maintaining work-life balance.\n\n**1. The Power of Time Blocking**\nTime blocking is a game-changer for remote workers...\n\nWould you like me to continue with the full post or adjust the tone?"
    );

    updateConversation(conv.id, { isPinned: true });
  }
}

